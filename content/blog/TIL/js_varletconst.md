자바스크립트의 변수 선언 키워드 ```var```, ```let```, ```const```에 관한 내용 총정리. 이제 다시는 찾아보지 말자.



### 스코프

var와 let, const를 구분하는 차이를 이해하기 위해서는 먼저 **스코프scope** 개념에 대한 이해가 필요하다.

스코프는 **"유효 범위"**다. 스코프가 변수를 참조할 수 있는 범위를 결정하는 것이다. 함수의 매개변수는 함수 몸체 내부에서만 참조할 수 있다. 즉, 함수 매개변수의 스코프는 '함수 몸체 내부'인 것이다.

그렇다면 변수의 스코프는 어떻게 정해지는 것일까?

> 모든 식별자는 **"자신이 선언된 위치"**에 의해 유효 범위가 결정된다.

즉, 스코프는 변수가 어디에서 선언되느냐에 의해 결정되는 것이다. 함수에서 선언된 매개변수의 스코프가 함수 내부에서만 참조 가능한 것처럼.

변수뿐만이 아니라 함수 이름, 클래스 이름 등 모든 식별자가 마찬가지 규칙을 따른다.

그렇다면 궁금해지는 것이 하나 있다. 만약 동일한 이름을 가진 변수의 스코프가 겹치는 경우는 어떻게 되는 걸까?

```javascript
var x = "global";

function foo() {
    var x = "local";
    console.log(x);
}

foo(); // ???
```

위 코드에서 첫 번째 변수 x는 전역에서 선언되었다. 그러나 foo 함수 내부에서 또 다른 변수 x가 선언되었다. 전역 변수 x는 어디에서나 참조할 수 있을 것이다. 반면 함수 내부의 x는 함수 내부에서만 참조할 수 있다. 그런데 함수 내부에서 x를 호출하면 '어디에서나 참조 가능한 x'와 '함수 내부에서 참조 가능한 x' 이 두 경우 모두에 해당이 된다.

함수 foo의 스코프가 전역 스코프에 포함이 되기 때문에 문제가 발생했다. 함수 내부에서 또 다른 함수가 선언되고 그 안에서 변수가 선언되면 새로운 스코프가 생성된다. 그 스코프는 foo 함수 스코프 한 단계 아래의 스코프를 갖는다. 이렇게 스코프가 계층적으로 연결된 것을 **스코프 체인**이라고 부른다. (스코프 체인의 실체와 관련해서는 **렉시컬 환경**을 찾아보자)

위 질문에 대한 해답을 스코프 체인에서 찾을 수 있다.

> 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여
>
> **상위 스코프 방향으로 이동하며** 선언된 변수를 검색한다.
>
> 변수가 존재하면, 해당 변수를 참조하고 검색을 종료한다.

이 설명을 통해 위 질문에 대한 답을 유추해볼 수 있다.

foo 함수 내부에서 참조된 x는 가장 가까운 스코프에서 선언된 변수 x가 있는지 탐색한다. 있다. ```var x = "local"```이다. 그리고 검색이 끝난다. 따라서 위 코드는 "local"을 출력한다.

만약 함수 내부에 x 변수 선언이 없었다면, 점점 상위 스코프로 탐색 범위를 이동하며 결국 마지막으로 전역에서 선언된 ```var x = "global"```을 만나게 될 것이다. 이제 전역 변수가 왜 전역에서 참조 가능한지도 알 게 된 것이다.



#### var, 그리고 함수 레벨 스코프

이제 본격적으로 변수 선언 키워드에 대해서 알아보고자 한다.

먼저 var 키워드는 오로지 **함수의 코드 블록**만을 지역 스코프로 인정한다. 이를 **함수 레벨 스코프**라고 한다.

코드의 블록은 다양하게 구분된다. if문이나 for문 내부의 블록, try/catch문 내부의 블록 등등. 이처럼 다양한 코드 블록이 존재하지만, var를 사용하여 함수 내부가 아닌 다른 블록에서 변수를 선언한다면 **모두 전역 변수**가 된다.

```javascript
var x = 1;

if(true) {
    var x = 2;
}

for(var x = 2; x < 3; x++) {
    console.log('foo');
}

function foo() {
    var x = 4;
    console.log(x);
}

console.log(x);	// 3
foo();	// 4
```

위 예시에서 함수 foo 내부에서 선언된 x를 제외하면, 나머지 x는 모두 전역 변수이다. 함수가 아닌 블록에서 var를 사용해 선언되었기 때문이다. 따라서 x는 전역 변수 중에서 가장 마지막에 선언된 for문 내부의 x를 참조하는 것이다.



#### 동적 스코프와 정적 스코프(렉시컬 스코프)

위에서 살펴본 것처럼 var로 선언한 변수는 함수 레벨 스코프를 따른다. 그러나 다른 키워드로 변수를 선언하거나, 혹은 자바스크립트가 아닌 다른 언어의 경우 함수 레벨 스코프가 아닌 블록 레벨 스코프를 따르기도 한다.

그렇지 않은 경우가 존재한다는 사실을 알고 있는 것은 중요하다.

그래서 동적 스코프와 정적 스코프에 대해서도 짧게 알고 넘어가보자.

```javascript
var x = 1;

function foo() {
    var x = 2;
    bar();
}

function bar() {
    console.log(x);
}

foo();	// ?
bar();	// ?
```

위에서 알아본 바에 의하면 자바스크립트의 **모든 식별자**는 '자신이 선언된 위치'에 의해 스코프가 결정된다고 했다.

따라서 전역에서 **정의**된 함수 bar는 전역 스코프를 갖는다. 비록 함수 foo 내부에서 **호출**되었지만 말이다. 이 규칙에 따르면 위 코드는 두 번 모두 전역 변수 x를 참조하여 1을 호출한다.

맞다. 자바스크립트는 "어디서 정의했는지에 따라 함수의 스코프를 결정"하기 때문이다. 이를 정적 스코프 혹은 렉시컬 스코프를 따른다고 말한다.

그렇지 않은 경우도 있다. 동적 스코프를 따르는 언어도 있다.

동적 스코프는 정의되는 위치가 아니라 "호출되는 위치"에 따라 스코프가 결정된다. 함수를 정의하는 시점에는 스코프를 알 수 없고, 호출되는 시점에 동적으로 상위 스코프가 정해지는 것이다.

(렉시컬 스코프를 이해했다면 **클로져closure**에 대해서 공부해보자)



왜 var가 문제가 되는 걸까?

