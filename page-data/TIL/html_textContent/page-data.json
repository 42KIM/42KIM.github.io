{"componentChunkName":"component---src-templates-blog-post-js","path":"/TIL/html_textContent/","result":{"data":{"site":{"siteMetadata":{"title":"42Log"}},"markdownRemark":{"id":"69083a3e-7b70-59d8-8e49-db35b2f5ae02","excerpt":"HTML element의 텍스트를 가져오거나, 또는 텍스트를 추가해야 하는 경우가 종종 생긴다. 이를 수행할 수 있는 몇 가지 방법이 있다. , , 의 차이점을 알아보고 무엇을 사용하는 것이 좋을지 알아보자. HTML…","html":"<p>HTML element의 텍스트를 가져오거나, 또는 텍스트를 추가해야 하는 경우가 종종 생긴다. 이를 수행할 수 있는 몇 가지 방법이 있다. <code class=\"language-text\">textContent</code>, <code class=\"language-text\">innerText</code>, <code class=\"language-text\">innerHTML</code>의 차이점을 알아보고 무엇을 사용하는 것이 좋을지 알아보자.</p>\n<p>HTML이 다음과 같이 작성되었을 때, 각각 어떤 차이를 보일까.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n    Do\n    you   see <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>span</span> <span class=\"token style-attr\"><span class=\"token attr-name\">style</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span><span class=\"token style language-css\"><span class=\"token property\">display</span><span class=\"token punctuation\">:</span> none</span><span class=\"token punctuation\">\"</span></span></span><span class=\"token punctuation\">></span></span>the difference?<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>span</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<h3>innerHTML</h3>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> div <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"div\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>div<span class=\"token punctuation\">.</span>innerHTML<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Do</span>\n<span class=\"token comment\">// you   see &lt;span style=\"display: none\">the difference?&lt;/span></span></code></pre></div>\n<p><code class=\"language-text\">innerHTML</code>을 사용해 div 요소에 접근하면, div 태그 내부에 작성한 모든 내용을 토씨 하나 틀린 것 없이 그대로 가져온다. 해당 태그 내부에 작성된 ‘모든 HTML 마크업’을 문자열 형태로 긁어오는 것이다.</p>\n<p>반대로 innerHTML을 사용해 요소에 내용을 설정할 때는 HTML이 파싱된 결과가 화면에 출력된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">div<span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">=</span> <span class=\"token string\">'&lt;span style=\"color: red\">hello world&lt;/span>'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위와 같은 코드가 작성되었다면, 화면에는  </p>\n<p><span style=\"color: red\">hello world</span>  </p>\n<p>가 출력되는 것이다.</p>\n<p>이 말인 즉슨, innerHTML을 사용하는 동안 XSS 공격을 당할 경우 작성자가 원치 않는 HTML 마크업이 스크립트에 추가 또는 삭제될 수 있다는 위험성이 있다는 것을 의미한다.  </p>\n<p>또한 HTML 파싱에 소요되는 비용이 성능에 영향을 끼친다.</p>\n<h3>innerText</h3>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> div <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"div\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>div<span class=\"token punctuation\">.</span>innerText<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Do you see</span></code></pre></div>\n<p><code class=\"language-text\">innerText</code>를 사용하여 div 요소에 접근하면, 브라우저에 출력되는 것과 동일한 결과물을 가져온다. 즉, 사용자에게 ‘보여지는 텍스트’ 값을 읽어오는 것이다. (사용자가 화면을 드래그하여 복사+붙여넣기 한 결과와 동일한 것)</p>\n<p>임의의 줄바꿈과 3칸의 공백은 한 칸의 공백으로 처리되었고, display: none이 적용되어 화면에 보이지 않는 텍스트도 가져오지 않는다. 즉, innetText는 CSS까지 반영된 최종 렌더링 결과를 가져온다는 것을 알 수 있다.</p>\n<p>또한 innerText를 사용하여 값을 설정하는 경우에는 렌더링 된 최신 값을 계산하여 반영하기 위한 <code class=\"language-text\">Reflow</code>가 발생하게 되어 화면의 깜빡거림이 발생하게 되고, 당연히 성능도 그만큼 떨어질 수밖에 없는 것이다.<br>\n(과거 버전의 IE 브라우저에서는 textContent를 지원하지 않았기 때문에 innerText는 IE 브라우저에 적합하게 만들어졌다고 한다. 따라서 IE 환경에서는 innerText의 성능이 가장 좋다고 한다. 하지만 IE는 죽었어..)</p>\n<h3>textContent</h3>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> div <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"div\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>div<span class=\"token punctuation\">.</span>textContent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Do</span>\n<span class=\"token comment\">// you   see the difference?</span></code></pre></div>\n<p><code class=\"language-text\">textContent</code>는 innerHTML과 innerText의 중간쯤이라고 보면 된다.</p>\n<p>innerHTML과 마찬가지로 공백이나 줄바꿈을 작성된 상태 그대로, display가 none인 자식 태그의 내용도 가져오지만, 태그를 제외한 오로지 ‘텍스트’ 값만 골라서 가져오기 때문이다.</p>\n<p>반면 innerHTML처럼 HTML로 분석해야 하거나, innerText처럼 렌더링 이후의 값을 계산하지 않기 때문에 셋 중에서 가장 성능이 좋다.</p>\n<p>이처럼 각각의 특징을 고려하여<br>\nHTML 마크업 원본의 구성을 파악하고 싶다면 innerHTML,<br>\n화면에 렌더링 되는 텍스트만 확인하고 싶다면 innerText,<br>\n렌더링된 텍스트에 어떤 스타일이 적용되었는지를 확인하려면 textContent를 사용하는 식으로 상황에 맞게 사용하면 좋을 것 같다.</p>\n<h4>참고</h4>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/API/Node/textContent\">MDN Web Docs</a><br>\n<a href=\"https://betterprogramming.pub/whats-best-innertext-vs-innerhtml-vs-textcontent-903ebc43a3fc\">What’s Best: innerText vs. innerHTML vs. textContent</a></p>","frontmatter":{"title":"[TIL]] textContent / innerText / innerHTML 차이","date":"July 05, 2021","description":null}},"previous":{"fields":{"slug":"/TIL/js_addeventlistener/"},"frontmatter":{"title":"[JS] addEventListener의 이벤트 핸들러와 this"}},"next":{"fields":{"slug":"/TIL/js_reduce/"},"frontmatter":{"title":"[TIL] reduce() 메서드가 NaN을 반환하는 이유"}}},"pageContext":{"id":"69083a3e-7b70-59d8-8e49-db35b2f5ae02","previousPostId":"ed812e78-20bc-5c2b-a71d-c8ff4bc55063","nextPostId":"2e081d5a-b83c-58a2-aa68-36361914f45b"}},"staticQueryHashes":["2841359383","3257411868"]}